#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#include "dvar_list.h"
#include "dvar_hashes.h"

typedef unsigned char byte;

unsigned int Dvar_Hash(const char *namehash)
{
    byte v4;
    unsigned int hash;
    byte v6;

    if (namehash[0] != '0' || namehash[1] != 'x')
    {
        v4 = namehash[0];
        if ((v4 - 65) <= 0x19)
            v4 += 32;

        hash = 0xB3CB2E29 * (v4 ^ 0x319712C3);
        if (namehash[0])
        {
            do
            {
                v6 = (namehash++)[1];
                if ((v6 - 65) <= 0x19u)
                    v6 += 32;
                hash = 0xB3CB2E29 * (hash ^ v6);
            } while (v6);
        }
    }
    else
    {
        sscanf(namehash, "0x%x", &hash);
    }
    return hash;
}

void build_dvar_list(const char* read_from_name)
{
    char *iter;
    char dvar[128];
    FILE *in;
    FILE *out;
    uint32_t hash;

    in = fopen(read_from_name, "r");
    if (!in)
    {
        fprintf(stderr, "Can't open dvar list '%s': %s\n", read_from_name, strerror(errno));
        return;
    }

    out = fopen("dvar_list.c", "w");
    if (!out)
    {
        fprintf(stderr, "Can't generate '%s': %s\n", "dvar_list.c", strerror(errno));
        fclose(in);
        return;
    }

    fprintf(out, "/* This file has been autogenerated. Modify at your own risk. */\n");
    fprintf(out, "#include \"dvar_hashes.h\"\n\n");
    fprintf(out, "const DvarHash g_dvar_hashes[] = {\n");
    while (fgets(dvar, 128, in))
    {
        iter = strchr(dvar, '\r');
        if (iter)
            *iter = '\0';
        iter = strchr(dvar, '\n');
        if (iter)
            *iter = '\0';
        
        hash = Dvar_Hash(dvar);
        printf("Hash for '%s': 0x%X\n", dvar, hash);

        fprintf(out, "    { \"%s\", 0x%X }", dvar, hash);
        fprintf(out, "%s\n", feof(in) ? "" : ",");
    }
    fprintf(out, "};\n");
    fprintf(out, "const int g_dvar_hashes_size = sizeof(g_dvar_hashes) / sizeof(DvarHash);\n");

    fclose(in);
    fclose(out);

    printf("Building done. Please, recompile this tool with newly generated file 'dvar_list.c'\n");
}

void print_dvar_list()
{
    int i;

    printf("Following list of hashes and dvars currently in use (%d total):\n", g_dvar_hashes_size);
    for (i = 0; i < g_dvar_hashes_size; ++i)
        printf("0x%08X - %s\n", g_dvar_hashes[i].hash, g_dvar_hashes[i].dvar);

    printf("To obtain list of dvars you can use regex: / \\w*\n/");
}

void tokenize_seta_line(char *line, char **seta, char **hash, char **rest)
{
    *seta = 0;
    *hash = 0;
    *rest = 0;

    *seta = strtok(line, " \t");
    *hash = strtok(0, " \t");
    *rest = *hash + strlen(*hash) + 1;
}

void unhexify_config_dvars(const char *path)
{
    char dvar[2048];
    FILE *in = 0;
    FILE *out = 0;
    char *iter;
    uint hash_value;
    char *seta;
    char *hash;
    char *rest;
    int i;

    in = fopen(path, "r");
    if (!in)
    {
        fprintf(stderr, "Can't open config file '%s': %s\n", path, strerror(errno));
        goto DONE;
    }

    out = fopen("new_config.cfg", "w");
    if (!out)
    {
        fprintf(stderr, "Can't open new config file 'new_config.cfg': %s\n", strerror(errno));
        goto DONE;
    }

    fprintf(out, "// Unhexified for MWRX usage purposes\n");

    while (fgets(dvar, 2048, in))
    {
        if (strncmp(dvar, "seta ", 5) && strncmp(dvar, "set ", 4))
        {
            fwrite(dvar, sizeof(char), strlen(dvar), out);
            continue;
        }

        iter = strchr(dvar, '\r');
        if (iter)
            *iter = '\0';
        iter = strchr(dvar, '\n');
        if (iter)
            *iter = '\0';

        tokenize_seta_line(dvar, &seta, &hash, &rest);
        sscanf(hash + 2, "%X", &hash_value);

        for (i = 0; i < g_dvar_hashes_size; ++i)
        {
            if (g_dvar_hashes[i].hash == hash_value)
            {
                printf("Found dvar hash for '%s'\n", g_dvar_hashes[i].dvar);
                fprintf(out, "%s %s %s\n", seta, g_dvar_hashes[i].dvar, rest);
                goto CONTINUE;
            }
        }

        fprintf(out, "%s %s %s\n", seta, hash, rest);

        CONTINUE:
        continue; /* Just to avoid empty ";" line. */
    }

    printf("Hash decoding in config done. Note that not anything may be decoded.\n");
    DONE:
    if (in)
        fclose(in);
    if (out)
        fclose(out);
}

int convert_to_uppercase(const char *str, const int count, char *out, const int out_size)
{
    int i;

    if (out_size < count)
    {
        fprintf(stderr, "out_size cannot be less that requested count. Increase buffer size.\n");
        return 0;
    }

    for (i = 0; i < count; ++i)
    {
        out[i] = str[i];
        if (out[i] >= 'a' && out[i] <= 'z')
            out[i] -= 0x20;
    }

    out[count] = '\0';
    return 1;
}

void build_dvar_enum()
{
    int i;
    FILE *out = 0;
    char uppercase_dvar[128];

    out = fopen("dvar_hashes_enum.h", "w");
    if (!out)
    {
        fprintf(stderr, "Can't open 'dvar_hashes_enum.h': %s\n", strerror(errno));
        return;
    }
    
    printf("Building dvar hashes enum... (%d total records)\n", g_dvar_hashes_size);

    fprintf(out, "/* This file is autogenerated. Modify at your own risk. */\n");
    fprintf(out, "#ifndef DVAR_HASHES_ENUM_H\n");
    fprintf(out, "#define DVAR_HASHES_ENUM_H\n");
    fprintf(out, "#pragma once\n\n");
    fprintf(out, "typedef enum DvarHashEnum \n{\n");
    for (i = 0; i < g_dvar_hashes_size; ++i)
    {
        if (!convert_to_uppercase(g_dvar_hashes[i].dvar, (int)strlen(g_dvar_hashes[i].dvar), uppercase_dvar, sizeof(uppercase_dvar)))
        {
            fprintf(stderr, "Warning: ignoring enum entry for '%s' dvar\n", g_dvar_hashes[i].dvar);
            continue;
        }

        printf("Adding enum entry for '%s' dvar.\n", g_dvar_hashes[i].dvar);
        fprintf(out, "    DHE_%s = 0x%X", uppercase_dvar, g_dvar_hashes[i].hash);
       
        if(i != g_dvar_hashes_size - 1)
            fwrite(",", sizeof(char), 1, out);

        fwrite("\n", sizeof(char), 1, out);
    }
    fprintf(out, "} DvarHashEnum;\n\n");
    fprintf(out, "#endif /* DVAR_HASHES_ENUM_H */\n");

    fclose(out);
    printf("Generating of enum done. You can use this file in your projects.\n");
}

int main(int argc, const char *argv[])
{
    if (argc > 1)
    {
        if (!strcmp(argv[1], "-b") && argc == 3)
            build_dvar_list(argv[2]);
        else if (!strcmp(argv[1], "-l"))
            print_dvar_list();
        else if (!strcmp(argv[1], "-e"))
            build_dvar_enum();
        else
            unhexify_config_dvars(argv[1]);
    }
    else
    {
        printf("unhexifycfg v1 Usage:\n");
        printf("%s <options [args]>\n", argv[0]);
        printf("Options:\n");
        printf("  -b <path> - Rebuild internal dvar list structure according to passed dvar list.\n");
        printf("  -l        - Show current dvar hashes list.\n");
        printf("  <cfg>     - Replace all known hashes in config to its string names.\n");
        printf("%d records in dvar hash table\n", g_dvar_hashes_size);
    }
    return 0;
}